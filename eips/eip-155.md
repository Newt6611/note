Original GitHub Link: https://github.com/ethereum/EIPs/blob/master/EIPS/eip-155.md

# EIP-155 學習筆記

## 摘要 (Summary)
EIP-155 提出了一個簡單的**重放攻擊保護 (Replay Attack Protection)** 機制。
在此 EIP 實施之前，一個有效的以太坊交易可以被直接複製並在其他兼容以太坊的鏈（如 Ethereum Classic）上廣播並執行，因為它們的交易格式完全相同。
EIP-155 透過在交易簽名數據中引入 `CHAIN_ID`，確保了交易只能在特定鏈上有效，從而實現了跨鏈的交易隔離。

## 動機 (Motivation)
- **防止重放攻擊**：最主要的動機是防止用戶在主網發送交易時，該交易被惡意或無意地在測試網或分叉鏈（如 ETC）上重放，導致資金意外轉移。
- **鏈的識別**：為不同的以太坊網路（Mainnet, Ropsten, Rinkeby, Goerli 等）分配唯一的標識符。

## 規範細節 (Specification Details)
- **參數變更**：
  - 簽名雜湊 (Signing Hash) 的 RLP 編碼內容從原來的 6 個參數增加到 9 個：
    `rlp([nonce, gasprice, startgas, to, value, data, chainid, 0, 0])`
    *注意：最後兩個 `0` 是作為 `r` 和 `s` 的佔位符。*
- **`v` 值計算**：
  - 新的 `v` 值計算公式為：`v = {0,1} + CHAIN_ID * 2 + 35`。
  - `{0,1}` 是橢圓曲線簽名的恢復 ID (recovery id)。
  - 這使得 `v` 值變得很大（例如主網 ChainID=1，v=37 或 38），與舊版 `v` (27 或 28) 明顯區分。
- **兼容性**：
  - 為了保持向後兼容，舊版的簽名方式（不包含 ChainID）仍然被視為有效，但不受重放保護。

## Go-Ethereum 實作程式碼 (Implementation)
相關程式碼位於 `core/types/transaction_signing.go`。Geth 定義了 `EIP155Signer` 來處理這種新的簽名邏輯。

[GitHub 原始碼連結](https://github.com/ethereum/go-ethereum/blob/master/core/types/transaction_signing.go)

```go
// core/types/transaction_signing.go

// EIP155Signer implements Signer using the EIP-155 rules.
type EIP155Signer struct {
    chainId, chainIdMul *big.Int
}

func NewEIP155Signer(chainId *big.Int) EIP155Signer {
    if chainId == nil {
        chainId = new(big.Int)
    }
    return EIP155Signer{
        chainId:    chainId,
        chainIdMul: new(big.Int).Mul(chainId, big.NewInt(2)),
    }
}

// Hash returns the hash to be signed by the sender.
// It does not uniquely identify the transaction.
func (s EIP155Signer) Hash(tx *Transaction) common.Hash {
    return rlpHash([]interface{}{
        tx.Nonce(),
        tx.GasPrice(),
        tx.Gas(),
        tx.To(),
        tx.Value(),
        tx.Data(),
        s.chainId, uint(0), uint(0),
    })
}

// SignatureValues returns the raw R, S, V values corresponding to the
// given signature.
func (s EIP155Signer) SignatureValues(tx *Transaction, sig []byte) (r, s, v *big.Int, err error) {
    R, S, V, err := s.signer.SignatureValues(tx, sig)
    if err != nil {
        return nil, nil, nil, err
    }
    
    // 計算 EIP-155 的 V 值
    // v = {0,1} + CHAIN_ID * 2 + 35
    if s.chainId.Sign() != 0 {
        V = big.NewInt(int64(sig[64] + 35))
        V.Add(V, s.chainIdMul)
    }
    return R, S, V, nil
}
```

## 思考與疑問 (Thoughts & Questions)
- **為什麼是 +35？**
  - 原始的 `v` 是 27 或 28。
  - EIP-155 希望保留這個範圍給舊交易，並引入 ChainID。
  - 具體選擇 35 可能是為了避免與其他潛在的編碼衝突，或者僅僅是作為一個足夠大的偏移量。
- **安全性**：這是一個簡單有效的修復，但它依賴於客戶端正確實作並使用正確的 ChainID。如果用戶手動構造交易並忽略 ChainID，仍然容易受到攻擊。
- **未來**：現在的 EIP-1559 交易類型已經將 ChainID 作為交易結構的顯式字段，不再依賴於從 `v` 值中恢復，這使得解析更清晰。
