Original GitHub Link: https://github.com/ethereum/EIPs/blob/master/EIPS/eip-4844.md

# EIP-4844 學習筆記

## 摘要 (Summary)
EIP-4844 (Proto-Danksharding) 引入了一種新的交易類型，稱為「攜帶 Blob 的交易」(blob-carrying transactions)。這些交易包含大量的數據「Blobs」，這些數據不會被 EVM 永久儲存，而是由共識節點短期儲存（詳見 [[blob_lifecycle]]）。這旨在顯著降低 Layer 2 Rollups 將數據發佈到 Ethereum Layer 1 的成本。

## 動機 (Motivation)
隨著 Layer 2 解決方案的興起，數據可用性 (Data Availability) 成為 Ethereum 擴展的主要瓶頸。目前的 [[calldata]] 費用昂貴。EIP-4844 通過引入專門的、臨時的數據空間，為最終的 Full Danksharding 奠定基礎，並在短期內大幅降低 Rollup 的費用。

## 規範細節 (Specification Details)
- **新交易類型 (Transaction Type 3):** 包含 `blob_versioned_hashes`。
- **KZG 承諾 (KZG Commitments):** 用於驗證 Blob 數據而不需要讀取完整數據。
- **Blob Gas 市場:** 引入獨立於執行 Gas 的 `blob_gas` 定價機制，使用 `excess_blob_gas` 來動態調整費用。
- **BLOBHASH Opcode:** 允許智慧合約檢索交易中 Blob 的哈希。

## Go-Ethereum 實作程式碼 (Implementation)
相關程式碼主要位於 `core/types` 和 `consensus` 目錄下。

### Blob 交易定義
在 `core/types/tx_blob.go` 中定義了 `BlobTx` 結構：

```go
// core/types/tx_blob.go

type BlobTx struct {
	ChainID    *uint256.Int
	Nonce      uint64
	GasTipCap  *uint256.Int // a.k.a. maxPriorityFeePerGas
	GasFeeCap  *uint256.Int // a.k.a. maxFeePerGas
	Gas        uint64
	To         common.Address
	Value      *uint256.Int
	Data       []byte
	AccessList AccessList
	BlobFeeCap *uint256.Int // a.k.a. maxFeePerBlobGas
	BlobHashes []common.Hash

	// A blob transaction can optionally contain blobs. This field must be set when BlobTx
	// is used to create a transaction for signing.
	Sidecar *BlobTxSidecar `rlp:"-"`

	// Signature values
	V *uint256.Int
	R *uint256.Int
	S *uint256.Int
}
```

### 共識驗證邏輯
在 `consensus/misc/eip4844/eip4844.go` 中處理 Blob Gas 的計算：

```go
// consensus/misc/eip4844/eip4844.go

func CalcBlobFee(excessBlobGas uint64) *big.Int {
	return params.ExponentialCost(params.MinBlobGasPrice, excessBlobGas, params.BlobGaspriceUpdateFraction)
}
```

## 常見問題 (Q&A)

### 1. Blob 數據的保存期限通常是 18 天（4096 個 epochs），這對長期歸檔節點有什麼影響？
對 Ethereum Layer 1 的**歸檔節點 (Archive Nodes)** 而言，Blob 的引入意味著節點不再需要（也不被強制）永久保存這部分歷史數據。
- **存儲壓力減輕:** 歸檔節點只需要保存執行層的交易數據和狀態，而不需要保存龐大的 Blob 內容，這減緩了節點磁碟佔用的增長速度。
- **數據不可訪問性:** 一旦過期，透過標準的 L1 節點 API 將無法再檢索到這些 Blob 數據。如果歸檔節點想要提供歷史 Blob 查詢服務，它們必須主動在過期前備份這些數據，或者依賴外部的歷史數據網路。

### 2. Rollups 如何在 Blob 數據被刪除後確保其自身的數據安全性？
Blob 數據被刪除並不代表 Rollup 的歷史記錄消失，只是從 Ethereum L1 共識層中移除了。Rollups 通過以下方式確保數據安全：
- **Rollup 運營商存儲:** Rollup 的 Sequencer 和全節點必須自行保存完整的歷史交易數據，以供用戶查詢和同步狀態。
- **第三方索引服務:** 區塊鏈瀏覽器（如 Etherscan）、索引協議（如 The Graph）會索引並保存這些數據。
- **專用存儲網路:** 項目可能會將過期數據備份到去中心化存儲網路（如 Filecoin, Arweave）或新興的 DA 專用網路（如 EthStorage）。
- **信任最小化:** 只要 L1 上保留了 Blob 的 **KZG 承諾 (Commitment)**，任何人只要擁有 Blob 的原始數據（無論從哪裡獲得），都可以向 L1 證明該數據的真實性。

### 3. 為什麼選擇 KZG 而不是其他證明系統（如 STARKs）？
EIP-4844 選擇 KZG (Kate-Zaverucha-Goldberg) 承諾主要基於以下考量：
- **恆定大小 (Constant Size):** KZG 承諾和證明的大小非常小（48 bytes），且不會隨數據量增加而變大，這對鏈上存儲非常有利。
- **易於驗證:** 驗證 KZG 證明的計算成本相對較低，適合在 EVM 中通過預編譯合約 (Precompile) 執行。
- **支持數據可用性採樣 (DAS):** KZG 數學特性非常適合未來 Full Danksharding 需要的 DAS 技術，允許節點只需下載極少量的數據碎片就能驗證整個 Blob 的可用性。
- **STARKs 的劣勢:** 雖然 STARKs 不需要可信設置 (Trusted Setup) 且抗量子，但在當時其證明大小較大，且在 EVM 上的驗證成本較高，不如 KZG 適合當前的過渡階段。為了安全性，Ethereum 舉行了史上最大規模的 KZG 可信設置儀式 (Ceremony of the Tau) 來緩解受信任設置的風險。
