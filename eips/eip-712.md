Original GitHub Link: https://github.com/ethereum/EIPs/blob/master/EIPS/eip-712.md

# EIP-712 學習筆記

## 摘要 (Summary)
EIP-712 是一個針對「型別化結構數據」進行雜湊與簽章的標準（Typed structured data hashing and signing）。它旨在讓鏈下簽章的數據在簽署時對使用者是可閱讀的（human-readable），而不僅僅是一串難以理解的十六進位字串。該標準定義了如何將結構化數據轉化為雜湊值，並透過 Domain Separator 防止跨鏈或跨應用的重放攻擊（Replay Attack）。

## 動機 (Motivation)
在 EIP-712 出現之前，使用者在簽署訊息時（如透過 MetaMask），通常只能看到一段 `0x` 開頭的雜湊字串，這使得使用者難以驗證自己到底簽署了什麼內容，增加了釣魚攻擊的風險。
EIP-712 解決了以下問題：
1. **可閱讀性**：讓錢包能以結構化、易讀的格式顯示簽章內容。
2. **安全性**：透過強型別定義與網域分隔符（Domain Separator），確保簽章只能在特定的合約、特定的鏈上生效，防止簽章被盜用至其他環境。

## 規範細節 (Specification Details)
EIP-712 的核心包含三個部分：
1. **Type Hash**：對結構體類型的定義進行雜湊（例如 `Transaction(address from,address to,uint256 value)`）。
2. **Domain Separator**：包含 `name`, `version`, `chainId`, `verifyingContract`, `salt` 等欄位，用來唯一識別簽章的上下文。
3. **Encoding Rules**：定義了如何遞迴地對結構化數據進行編碼，最終產生一個唯一的雜湊值 `hashStruct(s) = keccak256(typeHash ‖ encodeData(s))`。

最終簽署的訊息格式為：`\x19\x01 ‖ domainSeparator ‖ hashStruct(message)`。

## Go-Ethereum 實作程式碼 (Implementation)
在 `go-ethereum` 中，相關的實作主要位於 `signer/core` 或 `common/hexutil` 以及特定的簽署工具包中。核心的型別化數據處理通常在 `signer/core/apitypes` 之中。

```go
// 參考 go-ethereum/signer/core/apitypes/types.go 中的 TypedData 結構
type TypedData struct {
	Types       Types            `json:"types"`
	PrimaryType string           `json:"primaryType"`
	Domain      TypedDataDomain  `json:"domain"`
	Message     TypedDataMessage `json:"message"`
}

// 雜湊計算通常涉及以下邏輯：
// hashStruct(type, data) = keccak256(typeHash ‖ encodeData(data))
```

## 思考與疑問 (Thoughts & Questions)
- 為什麼 `\x19\x01` 被選為 EIP-712 的前綴？（為了與 EIP-191 相容並區分不同的簽章類型）。
- 在實作 `permit` (ERC-2612) 時，EIP-712 是如何降低 Gas 消耗的？（透過離線授權減少了一次 `approve` 的交易）。
- 如果 `chainId` 發生硬分叉變動，舊的 EIP-712 簽章會失效嗎？
