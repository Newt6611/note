Original GitHub Link: https://github.com/ethereum/EIPs/blob/master/EIPS/eip-2929.md

# EIP-2929 學習筆記

## 摘要 (Summary)
EIP-2929 提高了 `SLOAD`、`*CALL` 系列、`BALANCE`、`EXT*` 系列以及 `SELFDESTRUCT` 操作碼在交易中**首次使用**時的 Gas 成本。這引入了「冷（Cold）」與「熱（Warm）」訪問的概念：首次訪問（冷）成本較高，後續訪問（熱）成本較低。

## 動機 (Motivation)
- **防止 DoS 攻擊**：歷史上，儲存訪問操作（IO 操作）的定價偏低。攻擊者可以利用這一點，透過發送大量訪問不同帳戶或儲存槽的交易，導致節點處理時間過長（IO 瓶頸）。
- **Stateless Client 準備**：提高冷訪問成本有助於限制區塊的 Witness 大小，為未來的無狀態客戶端（Stateless Ethereum）鋪路。

## 規範細節 (Specification Details)
- **Gas 成本對照表**：

| 操作碼 (Opcode) | EIP-2929 之前 (Legacy) | EIP-2929 之後 (Cold) | EIP-2929 之後 (Warm) |
| :--- | :--- | :--- | :--- |
| **SLOAD** | 800 | 2100 | 100 |
| **CALL / STATICCALL** | 700 | 2600 | 100 |
| **BALANCE** | 700 | 2600 | 100 |
| **EXTCODESIZE / HASH** | 700 | 2600 | 100 |
| **SELFDESTRUCT** | 5000 | 7600 (若目標為 Cold) | 5000 (若目標為 Warm) |

- **參數**：
  - `COLD_SLOAD_COST`: 2100 Gas
  - `COLD_ACCOUNT_ACCESS_COST`: 2600 Gas
  - `WARM_STORAGE_READ_COST`: 100 Gas
- **機制**：
  - 交易執行時，維護兩個集合：`accessed_addresses`（已訪問地址）和 `accessed_storage_keys`（已訪問儲存鍵）。
  - **初始化**：交易開始時，`tx.sender`、`tx.to` 和預編譯合約地址會被自動加入 `accessed_addresses`。
  - **儲存讀取 (`SLOAD`)**：
    - 如果是**首次**訪問（不在集合中）：收費 `COLD_SLOAD_COST` (2100)，並加入集合。
    - 如果是**再次**訪問（已在集合中）：收費 `WARM_STORAGE_READ_COST` (100)。
  - **帳戶訪問 (`CALL`, `BALANCE`, `EXT*`)**：
    - 如果是**首次**訪問：收費 `COLD_ACCOUNT_ACCESS_COST` (2600)，並加入集合。
    - 如果是**再次**訪問：收費 `WARM_STORAGE_READ_COST` (100)。
  - **`SSTORE` 修改**：重置成本 `SSTORE_RESET_GAS` 調整為 `5000 - COLD_SLOAD_COST`。

## Go-Ethereum 實作程式碼 (Implementation)
Geth 將涉及 Access List (ACL) 相關的動態 Gas 計算邏輯移到了 `core/vm/operations_acl.go`。

`core/vm/operations_acl.go` 中實作了 `gasSLoadEIP2929`：

```go
// core/vm/operations_acl.go

// gasSLoadEIP2929 calculates dynamic gas for SLOAD according to EIP-2929
// For SLOAD, if the (address, storage_key) pair (where address is the address of the contract
// whose storage is being read) is not yet in accessed_storage_keys,
// charge 2100 gas and add the pair to accessed_storage_keys.
// If the pair is already in accessed_storage_keys, charge 100 gas.
func gasSLoadEIP2929(evm *EVM, contract *Contract, stack *Stack, mem *Memory, memorySize uint64) (uint64, error) {
	loc := stack.peek()
	slot := common.Hash(loc.Bytes32())
	// Check slot presence in the access list
	if _, slotPresent := evm.StateDB.SlotInAccessList(contract.Address(), slot); !slotPresent {
		// If the caller cannot afford the cost, this change will be rolled back
		// If he does afford it, we can skip checking the same thing later on, during execution
		evm.StateDB.AddSlotToAccessList(contract.Address(), slot)
		return params.ColdSloadCostEIP2929, nil
	}
	return params.WarmStorageReadCostEIP2929, nil
}
```

實際的常數定義在 `params/protocol_params.go` 中：
```go
const (
    ColdSloadCostEIP2929 = 2100
    ColdAccountAccessCostEIP2929 = 2600
    WarmStorageReadCostEIP2929 = 100
)
```

## 思考與疑問 (Thoughts & Questions)
- **Access List 的重要性**：EIP-2929 導致某些合約交互成本大幅增加，因此後續的 **EIP-2930** 引入了可選的 Access List 交易類型，允許用戶預先宣告將要訪問的地址和儲存槽，以預先支付較低的冷訪問費用（或者是為了確保交易不會因 Gas 不足而失敗）。
- **對開發者的影響**：開發者需要意識到，將多次讀取分散在不同交易中會比在同一筆交易中多次讀取更昂貴。緩存（Caching）在合約層面變得不那麼重要，因為協議層已經對「熱讀取」給予了極大的優惠（100 Gas vs 800 Gas pre-EIP-2929）。

## 關聯筆記 (Related)
- [[storage]]
- [[calldata]]